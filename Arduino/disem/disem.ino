/*
DISEM – Diagnostic Intelligent des Systèmes Électromécaniques
Author: LAAZIZ Youness & KEBE Mamadou
GitHub: https://github.com/laazizyounessgesii-ops/DISEM-End-to-End-Embedded-AI
Year: 2025-2026

ESP32-S3 + SCT-013 (ADC) + MPU6050 (I2C) + OLED SSD1306 (I2C)
- Extract 32 features (16 current + 16 vibration) exactly like Python:
  Time (10): mean, std, rms, min, max, ptp, median, MAD, skewness, kurtosis_excess
  Spectral (6): dom_freq, centroid, bandwidth, bp1(0-200), bp2(200-1000), bp3(1000-4000)
- Apply StandardScaler mean/scale from scaler_params.h
- Quantize to int8 using input tensor quant params
- Run TFLite Micro inference on INT8 model
- OLED shows predicted class + fault name, Fs, rmsAC
- LEDs: Green if C1 (Healthy), Red if C2..C7
*/

#include <Arduino.h>
#include <Wire.h>

// ===== OLED =====
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// ===== MPU6050 =====
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
Adafruit_MPU6050 mpu;

// ===== TFLM (Chirale_TensorFlowLite) =====
#include <Chirale_TensorFlowLite.h>
#include "model_data.h"  // must define: const unsigned char model_data[]; const unsigned int model_data_len;

#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/version.h"

// ===== Scaler =====
// Generated by export_scaler_to_h.py (must contain scaler_mean[] and scaler_scale[] and SCALER_DIM=32)
#include "scaler_params.h"

// ===================== PINS =====================
static const int I2C_SDA = 8;
static const int I2C_SCL = 9;

static const int ADC_PIN   = 5;   // SCT -> ADC (via 1k)
static const int LED_GREEN = 6;   // C1 healthy
static const int LED_RED   = 7;   // C2..C7 fault

// ===================== ADC / SIGNAL =====================
static const float VREF = 3.3f;
static const int ADC_MAX = 4095;      // 12-bit
static const int N = 256;             // samples per window
static const float TARGET_FS = 4000.0f; // used only as hint (we measure Fs_eff)

// SCT conditioning assumed OK:
// SCT wire A -> Vmid, wire B -> ADC_PIN via 1k, burden 47 ohm between A and B,
// Vmid from divider + 10uF to GND.

static uint16_t curRaw[N];
static float curV[N];     // volts
static float vibA[N];     // m/s^2 magnitude (or choose axis)

// ===================== TFLM Arena =====================
static constexpr int kArenaSize = 220 * 1024; // safe for ESP32-S3 N16R8
static uint8_t tensor_arena[kArenaSize];

const tflite::Model* model = nullptr;
tflite::MicroInterpreter* interpreter = nullptr;
TfLiteTensor* input = nullptr;
TfLiteTensor* output = nullptr;

// ===================== CLASS NAMES =====================
const char* CLASS_TEXT[7] = {
  "C1 Healthy",
  "C2 Stator short",
  "C3 Stator imbalance",
  "C4 Rotor broken bar",
  "C5 Misalignment",
  "C6 Bearing fault",
  "C7 Combined faults"
};

const char* CLASS_LONG[7] = {
  "Healthy condition",
  "Stator short-circuit",
  "Stator imbalance",
  "Rotor fault (broken bar)",
  "Mechanical misalignment",
  "Bearing fault",
  "Electrical+Mechanical"
};

// ===================== SMALL UTILS =====================
static inline float adcToVolt(uint16_t x) { return (float)x * (VREF / (float)ADC_MAX); }

static inline float clampf(float x, float a, float b) {
  if (x < a) return a;
  if (x > b) return b;
  return x;
}

static inline int8_t quantize_int8(float x, float scale, int zero_point) {
  int q = (int)lrintf((x / scale) + (float)zero_point);
  if (q < -128) q = -128;
  if (q > 127)  q = 127;
  return (int8_t)q;
}

static void setLEDs(int predClass) { // 1..7
  if (predClass == 1) {
    digitalWrite(LED_GREEN, HIGH);
    digitalWrite(LED_RED, LOW);
  } else {
    digitalWrite(LED_GREEN, LOW);
    digitalWrite(LED_RED, HIGH);
  }
}

// ===================== MATH HELPERS (no heavy libs) =====================
static float meanf(const float* x, int n) {
  float s = 0;
  for (int i = 0; i < n; i++) s += x[i];
  return s / (float)n;
}

static float stdf(const float* x, int n, float mu) {
  float s2 = 0;
  for (int i = 0; i < n; i++) {
    float d = x[i] - mu;
    s2 += d * d;
  }
  float v = s2 / (float)n;
  return sqrtf(v);
}

static float rmsf(const float* x, int n) {
  float s2 = 0;
  for (int i = 0; i < n; i++) s2 += x[i] * x[i];
  return sqrtf(s2 / (float)n);
}

static void minmaxf(const float* x, int n, float &xmin, float &xmax) {
  xmin = 1e9f; xmax = -1e9f;
  for (int i = 0; i < n; i++) {
    float v = x[i];
    if (v < xmin) xmin = v;
    if (v > xmax) xmax = v;
  }
}

static void copy_to_temp(const float* src, float* dst, int n) {
  for (int i = 0; i < n; i++) dst[i] = src[i];
}

static void insertion_sort(float* a, int n) {
  for (int i = 1; i < n; i++) {
    float key = a[i];
    int j = i - 1;
    while (j >= 0 && a[j] > key) { a[j + 1] = a[j]; j--; }
    a[j + 1] = key;
  }
}

static float medianf(const float* x, int n) {
  static float tmp[N]; // N=256
  copy_to_temp(x, tmp, n);
  insertion_sort(tmp, n);
  if ((n & 1) == 1) return tmp[n / 2];
  return 0.5f * (tmp[n / 2 - 1] + tmp[n / 2]);
}

static float madf(const float* x, int n, float med) {
  static float tmp[N];
  for (int i = 0; i < n; i++) tmp[i] = fabsf(x[i] - med);
  insertion_sort(tmp, n);
  if ((n & 1) == 1) return tmp[n / 2];
  return 0.5f * (tmp[n / 2 - 1] + tmp[n / 2]);
}

static float skewnessf(const float* x, int n, float mu, float sd) {
  const float eps = 1e-12f;
  float s = (sd > eps) ? sd : eps;
  float m3 = 0;
  for (int i = 0; i < n; i++) {
    float z = (x[i] - mu) / s;
    m3 += z * z * z;
  }
  return m3 / (float)n;
}

static float kurtosis_excessf(const float* x, int n, float mu, float sd) {
  const float eps = 1e-12f;
  float s = (sd > eps) ? sd : eps;
  float m4 = 0;
  for (int i = 0; i < n; i++) {
    float z = (x[i] - mu) / s;
    m4 += z * z * z * z;
  }
  return (m4 / (float)n) - 3.0f;
}

// ===================== SIMPLE FFT (RADIX-2, N must be power of 2) =====================
// We implement minimal FFT for N=256. Good enough for features.
static void fft_radix2(float* vReal, float* vImag, int n) {
  // bit reversal
  int j = 0;
  for (int i = 0; i < n; i++) {
    if (i < j) {
      float tr = vReal[i]; vReal[i] = vReal[j]; vReal[j] = tr;
      float ti = vImag[i]; vImag[i] = vImag[j]; vImag[j] = ti;
    }
    int m = n >> 1;
    while (m >= 1 && j >= m) { j -= m; m >>= 1; }
    j += m;
  }

  // butterflies
  for (int len = 2; len <= n; len <<= 1) {
    float ang = -2.0f * PI / (float)len;
    float wlen_r = cosf(ang);
    float wlen_i = sinf(ang);
    for (int i = 0; i < n; i += len) {
      float wr = 1.0f, wi = 0.0f;
      for (int k = 0; k < len / 2; k++) {
        int u = i + k;
        int v = i + k + len / 2;
        float vr = vReal[v] * wr - vImag[v] * wi;
        float vi = vReal[v] * wi + vImag[v] * wr;

        float ur = vReal[u];
        float ui = vImag[u];

        vReal[u] = ur + vr;
        vImag[u] = ui + vi;
        vReal[v] = ur - vr;
        vImag[v] = ui - vi;

        float nwr = wr * wlen_r - wi * wlen_i;
        float nwi = wr * wlen_i + wi * wlen_r;
        wr = nwr; wi = nwi;
      }
    }
  }
}

static float bandpower_from_mag2(const float* mag2, int n, float fs, float fmin, float fmax) {
  // Using trapezoid rule over bins. rfft bins 0..n/2
  int kmin = (int)ceilf(fmin * (float)n / fs);
  int kmax = (int)floorf(fmax * (float)n / fs);
  if (kmin < 0) kmin = 0;
  if (kmax > n/2) kmax = n/2;
  if (kmax <= kmin) return 0.0f;

  float df = fs / (float)n;
  float sum = 0.0f;
  for (int k = kmin; k < kmax; k++) {
    float y0 = mag2[k];
    float y1 = mag2[k + 1];
    sum += 0.5f * (y0 + y1) * df;
  }
  return sum / (float)n; // consistent with Python "psd_like = mag2/(n+eps)"
}

static void spectral_features(const float* x, int n, float fs,
                              float &domF, float &cent, float &bw,
                              float &bp1, float &bp2, float &bp3) {
  static float vr[N];
  static float vi[N];

  // remove mean
  float mu = meanf(x, n);
  for (int i = 0; i < n; i++) { vr[i] = x[i] - mu; vi[i] = 0.0f; }

  // apply Hamming window
  for (int i = 0; i < n; i++) {
    float w = 0.54f - 0.46f * cosf(2.0f * PI * (float)i / (float)(n - 1));
    vr[i] *= w;
  }

  fft_radix2(vr, vi, n);

  // mag^2 for bins 0..n/2
  static float mag2[N/2 + 1];
  for (int k = 0; k <= n/2; k++) {
    float ar = vr[k];
    float ai = vi[k];
    mag2[k] = ar*ar + ai*ai;
  }

  // dominant freq ignoring DC
  int domIdx = 1;
  float best = mag2[1];
  for (int k = 2; k <= n/2; k++) {
    if (mag2[k] > best) { best = mag2[k]; domIdx = k; }
  }
  domF = (float)domIdx * fs / (float)n;

  // centroid + bandwidth
  float denom = 0.0f;
  float num = 0.0f;
  for (int k = 0; k <= n/2; k++) {
    float f = (float)k * fs / (float)n;
    float p = mag2[k];
    denom += p;
    num += f * p;
  }
  if (denom < 1e-12f) denom = 1e-12f;
  cent = num / denom;

  float var = 0.0f;
  for (int k = 0; k <= n/2; k++) {
    float f = (float)k * fs / (float)n;
    float p = mag2[k];
    float d = (f - cent);
    var += d*d * p;
  }
  bw = sqrtf(var / denom);

  // bandpowers (match Python bands)
  float nyq = fs * 0.5f;
  float b1_hi = (200.0f < nyq) ? 200.0f : nyq;
  float b2_hi = (1000.0f < nyq) ? 1000.0f : nyq;
  float b3_hi = (4000.0f < nyq) ? 4000.0f : nyq;

  bp1 = bandpower_from_mag2(mag2, n, fs, 0.0f, b1_hi);
  bp2 = (b2_hi > 200.0f) ? bandpower_from_mag2(mag2, n, fs, 200.0f, b2_hi) : 0.0f;
  bp3 = (b3_hi > 1000.0f) ? bandpower_from_mag2(mag2, n, fs, 1000.0f, b3_hi) : 0.0f;
}

// ===================== FEATURE EXTRACTION (16 per channel) =====================
static void extract_16(const float* x, int n, float fs, float out16[16]) {
  float mu = meanf(x, n);
  float sd = stdf(x, n, mu);
  float r  = rmsf(x, n);
  float xmin, xmax;
  minmaxf(x, n, xmin, xmax);
  float ptp = xmax - xmin;
  float med = medianf(x, n);
  float mad = madf(x, n, med);
  float sk  = skewnessf(x, n, mu, sd);
  float ku  = kurtosis_excessf(x, n, mu, sd);

  float domF, cent, bw, bp1, bp2, bp3;
  spectral_features(x, n, fs, domF, cent, bw, bp1, bp2, bp3);

  out16[0]  = mu;
  out16[1]  = sd;
  out16[2]  = r;
  out16[3]  = xmin;
  out16[4]  = xmax;
  out16[5]  = ptp;
  out16[6]  = med;
  out16[7]  = mad;
  out16[8]  = sk;
  out16[9]  = ku;
  out16[10] = domF;
  out16[11] = cent;
  out16[12] = bw;
  out16[13] = bp1;
  out16[14] = bp2;
  out16[15] = bp3;
}

static void extract_32_current_vib(const float* cur, const float* vib, int n, float fs,
                                  float out32[32]) {
  float f1[16], f2[16];
  extract_16(cur, n, fs, f1);
  extract_16(vib, n, fs, f2);
  for (int i = 0; i < 16; i++) out32[i]      = f1[i];
  for (int i = 0; i < 16; i++) out32[16 + i] = f2[i];
}

// ===================== ACQUISITION =====================
static void acquire_window(float &Fs_eff, float &meanV, float &rmsAC) {
  // capture current (ADC) + vibration (MPU) in same loop, measure Fs_eff from timing
  const uint32_t t0 = micros();

  sensors_event_t a, g, temp;

  for (int i = 0; i < N; i++) {
    // current
    curRaw[i] = analogRead(ADC_PIN);
    curV[i] = adcToVolt(curRaw[i]);

    // vibration: read MPU (acc magnitude)
    mpu.getEvent(&a, &g, &temp);
    float ax = a.acceleration.x;
    float ay = a.acceleration.y;
    float az = a.acceleration.z;
    vibA[i] = sqrtf(ax*ax + ay*ay + az*az);

    // small pacing if too fast (optional)
    delayMicroseconds(0);
  }

  const uint32_t t1 = micros();
  float dt = (float)(t1 - t0) * 1e-6f;
  Fs_eff = (dt > 0) ? ((float)N / dt) : 0.0f;

  // mean + rms AC (remove mean)
  meanV = meanf(curV, N);
  float s2 = 0.0f;
  for (int i = 0; i < N; i++) {
    float ac = curV[i] - meanV;
    s2 += ac * ac;
  }
  rmsAC = sqrtf(s2 / (float)N);
}

// ===================== TFLM IO =====================
static void fill_input_int8_from_features(const float feats32[32]) {
  // Model is INT8 (quantized). We will:
  // 1) scale: (x - mean)/scale (StandardScaler)
  // 2) quantize using input tensor params (scale/zp)
  if (input->type != kTfLiteInt8) {
    Serial.println("ERR: Model input is not INT8. Use INT8 .tflite for ESP32.");
    return;
  }

  const int n = input->bytes / (int)sizeof(int8_t);
  if (n < 32) {
    Serial.print("ERR: input size < 32, n="); Serial.println(n);
    return;
  }
  if (SCALER_DIM != 32) {
    Serial.println("ERR: scaler_params.h SCALER_DIM must be 32.");
    return;
  }

  float in_scale = input->params.scale;
  int in_zp = input->params.zero_point;

  int8_t* xq = input->data.int8;

  for (int i = 0; i < 32; i++) {
    float x = feats32[i];
    float xn = (x - scaler_mean[i]) / scaler_scale[i];
    xq[i] = quantize_int8(xn, in_scale, in_zp);
  }

  // if model expects more than 32, fill rest with 0
  for (int i = 32; i < n; i++) xq[i] = quantize_int8(0.0f, in_scale, in_zp);
}

static int get_prediction_class(int &raw_best) { // returns 1..7
  raw_best = 0;

  if (output->type == kTfLiteInt8) {
    const int8_t* y = output->data.int8;
    int n = output->bytes / (int)sizeof(int8_t);

    int best = 0;
    for (int i = 1; i < n; i++) {
      if (y[i] > y[best]) best = i;
    }
    raw_best = (int)y[best];
    return best + 1;
  }

  if (output->type == kTfLiteFloat32) {
    const float* y = output->data.f;
    int n = output->bytes / (int)sizeof(float);

    int best = 0;
    for (int i = 1; i < n; i++) {
      if (y[i] > y[best]) best = i;
    }
    raw_best = (int)(y[best] * 1000.0f);
    return best + 1;
  }

  Serial.println("ERR: output tensor type not supported.");
  return 1;
}

// ===================== OLED =====================
static void oled_show(float Fs_eff, float meanV, float rmsAC, int predClass) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  display.setCursor(0, 0);
  display.print("Fs: "); display.print(Fs_eff, 1); display.println(" Hz");

  display.setCursor(0, 12);
  display.print("mean: "); display.print(meanV, 3); display.println(" V");

  display.setCursor(0, 24);
  display.print("rmsAC: "); display.print(rmsAC, 4); display.println(" V");

  display.setCursor(0, 38);
  display.print("Pred: ");
  display.print(CLASS_TEXT[predClass - 1]);

  display.setCursor(0, 52);
  display.print(CLASS_LONG[predClass - 1]);

  display.display();
}

// ===================== SETUP =====================
void setup() {
  Serial.begin(115200);
  delay(300);

  pinMode(LED_GREEN, OUTPUT);
  pinMode(LED_RED, OUTPUT);
  digitalWrite(LED_GREEN, LOW);
  digitalWrite(LED_RED, LOW);

  // ADC config
  analogReadResolution(12);
  analogSetPinAttenuation(ADC_PIN, ADC_11db); // ~0..3.3V

  // I2C
  Wire.begin(I2C_SDA, I2C_SCL);

  // OLED
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("OLED FAIL");
  } else {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.println("OLED OK");
    display.display();
    delay(400);
  }

  // MPU6050
  if (!mpu.begin(0x68, &Wire)) {
    Serial.println("MPU6050 FAIL");
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("MPU6050 FAIL");
    display.display();
    while (1) delay(1000);
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  // ===== TFLM init =====
  Serial.println("Init TFLM...");

  model = tflite::GetModel(model_data);
  if (model->version() != TFLITE_SCHEMA_VERSION) {
    Serial.print("Model schema mismatch. Expected ");
    Serial.print(TFLITE_SCHEMA_VERSION);
    Serial.print(" got ");
    Serial.println(model->version());
  }

  // Resolver (enough for Dense/ReLU/Softmax + quant ops)
  static tflite::MicroMutableOpResolver<12> resolver;
  resolver.AddFullyConnected();
  resolver.AddSoftmax();
  resolver.AddReshape();
  resolver.AddQuantize();
  resolver.AddDequantize();
  resolver.AddAdd();
  resolver.AddMul();
  resolver.AddRelu();
  resolver.AddLogistic();
  resolver.AddTanh();

  static tflite::MicroInterpreter static_interpreter(
    model, resolver, tensor_arena, kArenaSize
  );
  interpreter = &static_interpreter;

  if (interpreter->AllocateTensors() != kTfLiteOk) {
    Serial.println("AllocateTensors() FAILED");
    while (1) delay(1000);
  }

  input = interpreter->input(0);
  output = interpreter->output(0);

  Serial.print("Input type="); Serial.println(input->type);
  Serial.print("Input bytes="); Serial.println(input->bytes);
  Serial.print("Output type="); Serial.println(output->type);
  Serial.print("Output bytes="); Serial.println(output->bytes);

  Serial.println("READY.");
}

// ===================== LOOP =====================
void loop() {
  float Fs_eff = 0.0f, meanV = 0.0f, rmsAC = 0.0f;

  // 1) Acquire
  acquire_window(Fs_eff, meanV, rmsAC);

  // 2) Features (32)
  float feats32[32];
  extract_32_current_vib(curV, vibA, N, Fs_eff, feats32);

  // 3) Fill input INT8 (Scaler + quant)
  fill_input_int8_from_features(feats32);

  // 4) Inference
  if (interpreter->Invoke() != kTfLiteOk) {
    Serial.println("Invoke FAILED");
    digitalWrite(LED_GREEN, LOW);
    digitalWrite(LED_RED, HIGH);
    delay(200);
    return;
  }

  // 5) Read prediction
  int rawdbg = 0;
  int predClass = get_prediction_class(rawdbg);
  predClass = (int)clampf((float)predClass, 1.0f, 7.0f);

  // 6) Output
  setLEDs(predClass);
  oled_show(Fs_eff, meanV, rmsAC, predClass);

  Serial.print("Fs_eff="); Serial.print(Fs_eff, 1);
  Serial.print("  Pred="); Serial.print(CLASS_TEXT[predClass - 1]);
  Serial.print("  raw_int8="); Serial.print(rawdbg);
  Serial.print("  meanV="); Serial.print(meanV, 6);
  Serial.print("  rmsAC="); Serial.println(rmsAC, 6);

  delay(250); // refresh ~4 Hz
}
